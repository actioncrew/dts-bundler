# TypeScript Declaration Bundler

A powerful TypeScript declaration (.d.ts) bundler for monorepos and multi-package projects. Creates self-contained, dependency-free bundles by intelligently inlining types and resolving cross-package dependencies using advanced dependency graph analysis.

## What it does

This tool analyzes your TypeScript declaration files, builds a complete dependency graph, and creates bundled `.d.ts` files that include all necessary type definitions. Perfect for libraries that need to distribute clean, self-contained declaration files without external dependencies.

## Installation

```bash
npm install --save-dev @actioncrew/dts-bundler
```

## Quick Start

1. **Initialize configuration**: Creates a `dts-bundler.config.json` file with project-specific defaults
   ```bash
   npx dts-bundler init
   ```

2. **Bundle declarations**: Analyzes dependencies and creates optimized bundles
   ```bash
   npx dts-bundler
   ```

3. **Find your bundles**: Check the `dist/bundles/` directory for `.bundle.d.ts` files

## Commands

| Command | Description |
|---------|-------------|
| `npx dts-bundler` | Bundle all entry points using configuration |
| `npx dts-bundler init` | Initialize configuration file |
| `npx dts-bundler --config <path>` | Use custom configuration file |
| `npx dts-bundler --verbose` | Enable detailed logging |
| `npx dts-bundler --include-comments` | Preserve comments in bundles |
| `npx dts-bundler --banner "Custom banner"` | Add custom banner text |
| `npx dts-bundler --help` | Show help information |

## Features

- ✅ **Dependency Graph Analysis**: Advanced TypeScript AST analysis with cycle detection
- ✅ **Smart Type Inlining**: Only inlines types that are actually used
- ✅ **Cross-Package Resolution**: Handles complex monorepo dependencies
- ✅ **Topological Sorting**: Bundles in correct dependency order
- ✅ **External Import Preservation**: Keeps third-party imports intact
- ✅ **TypeScript Integration**: Full compiler API integration with type checking
- ✅ **Configuration-Driven**: Flexible setup for any project structure
- ✅ **Validation**: Ensures bundled output compiles correctly
- ✅ **Source Maps Support**: Optional source map generation
- ✅ **CI/CD Ready**: Perfect for automated build pipelines

## Project Structure

The bundler works with various project structures, but here's a typical monorepo setup:

```
your-project/
├── packages/
│   ├── core/
│   │   └── dist/
│   │       └── index.d.ts
│   ├── utils/
│   │   └── dist/
│   │       └── index.d.ts
│   └── components/
│       └── dist/
│           └── index.d.ts
├── dist/
│   └── bundles/           # Generated bundles
│       ├── core.bundle.d.ts
│       ├── utils.bundle.d.ts
│       └── components.bundle.d.ts
├── dts-bundler.config.json # Configuration
├── tsconfig.json          # TypeScript config
└── package.json           # Project metadata
```

## Configuration

Run `npx dts-bundler init` to create a `dts-bundler.config.json` file:

```json
{
  "tsconfig": "tsconfig.json",
  "packageName": "@your-org/your-package",
  "distRoot": "dist",
  "outputDir": "bundles",
  "includeComments": false,
  "banner": "/**\n * @your-org/your-package - TypeScript Declaration Bundles\n * Generated by dts-bundler\n */",
  "exclude": [
    "**/*.spec.ts",
    "**/*.test.ts", 
    "**/node_modules/**"
  ],
  "include": [
    "**/*.d.ts"
  ],
  "verbose": false,
  "validateOutput": true
}
```

### Configuration Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `tsconfig` | `string` | `"tsconfig.json"` | Path to TypeScript configuration file |
| `packageName` | `string` | Auto-detected | Main package name for alias resolution |
| `distRoot` | `string` | `"dist"` | Root directory containing compiled .d.ts files |
| `outputDir` | `string` | `"bundles"` | Output directory for bundled files |
| `includeComments` | `boolean` | `false` | Preserve comments in bundled output |
| `banner` | `string` | Auto-generated | Banner text at top of each bundle |
| `compilerOptions` | `object` | `{}` | Custom TypeScript compiler options |
| `exclude` | `string[]` | See above | File patterns to exclude from bundling |
| `include` | `string[]` | `["**/*.d.ts"]` | File patterns to include (overrides exclude) |
| `verbose` | `boolean` | `false` | Enable detailed logging |
| `validateOutput` | `boolean` | `true` | Validate bundled output compiles correctly |
| `entryPoints` | `object` | Auto-detected | Manual entry point overrides |

### Advanced Configuration

For complex projects with custom requirements:

```json
{
  "tsconfig": "./build/tsconfig.declarations.json",
  "packageName": "@myorg/platform",
  "distRoot": "./build/declarations",
  "outputDir": "./publish/types",
  "includeComments": true,
  "banner": "// MyOrg Platform Types v1.0.0",
  "compilerOptions": {
    "target": "ES2020",
    "strict": true,
    "declaration": true
  },
  "exclude": [
    "**/*.spec.ts",
    "**/*.test.ts",
    "**/internal/**",
    "**/node_modules/**"
  ],
  "include": [
    "packages/*/dist/**/*.d.ts",
    "libs/*/dist/**/*.d.ts"
  ],
  "verbose": true,
  "validateOutput": true,
  "entryPoints": {
    "@myorg/platform/core": "./packages/core/dist/index.d.ts",
    "@myorg/platform/utils": "./packages/utils/dist/index.d.ts"
  }
}
```

### Manual Entry Points

Override automatic entry point detection:

```json
{
  "entryPoints": {
    "@mypackage/module-a": "./dist/module-a/index.d.ts",
    "@mypackage/module-b": "./dist/module-b/index.d.ts",
    "@mypackage/shared": "./dist/shared/types.d.ts"
  }
}
```

## How It Works

### 1. Dependency Graph Analysis

The bundler analyzes your TypeScript declaration files to build a complete dependency graph:

```typescript
// core/types.d.ts
export interface User {
  id: string;
  name: string;
}

// utils/helpers.d.ts  
import { User } from '@myorg/core';
export declare function processUser(user: User): string;

// components/user-card.d.ts
import { User } from '@myorg/core';
import { processUser } from '@myorg/utils';
export declare class UserCard {
  user: User;
  process(): string;
}
```

**Dependency Graph:**
```
components/user-card.d.ts → utils/helpers.d.ts → core/types.d.ts
```

### 2. Topological Sorting

Bundles are created in dependency order to ensure all dependencies are available:

```
Bundle order:
1. core.bundle.d.ts     (no dependencies)
2. utils.bundle.d.ts    (depends on core) 
3. components.bundle.d.ts (depends on utils, core)
```

### 3. Smart Type Inlining

Only types that are actually imported and used are inlined:

**components.bundle.d.ts:**
```typescript
// External imports (preserved)
import type * as React from 'react';

// Inter-package imports
import { User } from '@myorg/core';
import { processUser } from '@myorg/utils';

// Inlined declarations from other packages
interface User {
  id: string;
  name: string;
}

declare function processUser(user: User): string;

// Main declarations from this package
export declare class UserCard {
  user: User;
  process(): string;
}

// Bundled exports
export { UserCard };
```

## CLI Usage

### Basic Usage

```bash
# Bundle using configuration file
npx dts-bundler

# Initialize new project
npx dts-bundler init
```

### With Options

```bash
# Verbose output
npx dts-bundler --verbose

# Include comments in bundles
npx dts-bundler --include-comments

# Custom banner
npx dts-bundler --banner "// My Custom Banner"

# Custom config file
npx dts-bundler --config ./custom-bundler.config.json
```

### Configuration Override

Command line options override configuration file settings:

```bash
# Force verbose even if config has verbose: false
npx dts-bundler --verbose

# Add comments even if config has includeComments: false
npx dts-bundler --include-comments
```

## Output Examples

### Before Bundling

**Package A (dist/package-a/index.d.ts):**
```typescript
export interface ConfigOptions {
  apiUrl: string;
  timeout: number;
}
```

**Package B (dist/package-b/index.d.ts):**
```typescript
import { ConfigOptions } from '@myorg/package-a';
export declare class ApiClient {
  constructor(options: ConfigOptions);
  fetch(path: string): Promise<any>;
}
```

### After Bundling

**package-b.bundle.d.ts:**
```typescript
/**
 * @myorg/myproject - TypeScript Declaration Bundles
 * Generated by dts-bundler
 */

// Inter-package imports
import { ConfigOptions } from '@myorg/package-a';

// Inlined declarations from other packages
interface ConfigOptions {
  apiUrl: string;
  timeout: number;
}

// From: index.d.ts
declare class ApiClient {
  constructor(options: ConfigOptions);
  fetch(path: string): Promise<any>;
}

// Bundled exports
export { ApiClient };
```

## Advanced Use Cases

### Monorepo with Shared Types

```json
{
  "packageName": "@myorg/platform",
  "entryPoints": {
    "@myorg/platform/shared": "./packages/shared/dist/index.d.ts",
    "@myorg/platform/client": "./packages/client/dist/index.d.ts", 
    "@myorg/platform/server": "./packages/server/dist/index.d.ts"
  }
}
```

### Library Distribution

Bundle for npm package distribution:

```json
{
  "distRoot": "./lib",
  "outputDir": "./types",
  "includeComments": true,
  "banner": "// MyLibrary v{{VERSION}} - Type Definitions",
  "validateOutput": true
}
```

### CI/CD Integration

```yaml
# .github/workflows/build.yml
name: Build and Bundle
on: [push, pull_request]

jobs:
  bundle:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - run: npm ci
      - run: npm run build
      - run: npx dts-bundler --verbose
      
      - name: Upload bundles
        uses: actions/upload-artifact@v3
        with:
          name: type-bundles
          path: dist/bundles/
```

## Troubleshooting

### Common Issues

#### Entry Points Not Found
```
No .d.ts entry points found!
```

**Solutions:**
1. Ensure your TypeScript compilation is complete
2. Check `distRoot` path in configuration
3. Verify `tsconfig.json` paths are correct
4. Use `--verbose` to see what files are being discovered

#### Circular Dependencies
```
⚠️ Circular dependencies detected:
  package-a.d.ts → package-b.d.ts → package-a.d.ts
```

**Solutions:**
1. Refactor code to eliminate circular imports  
2. Extract shared types to a common package
3. Use type-only imports where possible

#### TypeScript Compilation Errors
```
TypeScript errors found:
  error TS2307: Cannot find module '@myorg/types'
```

**Solutions:**
1. Ensure all referenced packages are built
2. Check `paths` configuration in `tsconfig.json`
3. Verify `packageName` matches your actual package structure

#### Bundle Validation Failed
```
Validation errors in bundled output:
  error TS2304: Cannot find name 'SomeType'
```

**Solutions:**
1. Check if external dependencies are properly marked
2. Ensure all used types are properly imported
3. Add missing types to `include` patterns

### Debug Mode

Enable detailed logging to diagnose issues:

```bash
npx dts-bundler --verbose
```

This will show:
- Configuration being used
- Entry points discovered
- Files being processed
- Dependency graph structure
- Bundle generation progress

### Configuration Validation

The bundler validates your configuration and provides helpful error messages:

```bash
npx dts-bundler
❌ Configuration validation failed:
  - TypeScript config file not found: ./missing-tsconfig.json
  - Invalid package name format: invalid@name!
  - Cannot create output directory: /readonly/path
```

## Performance Tips

### Large Projects

For projects with many files:

1. **Use specific include patterns:**
   ```json
   {
     "include": ["packages/*/dist/index.d.ts"]
   }
   ```

2. **Exclude unnecessary files:**
   ```json
   {
     "exclude": [
       "**/*.spec.ts",
       "**/*.test.ts",
       "**/internal/**"
     ]
   }
   ```

3. **Limit bundling scope:**
   ```json
   {
     "entryPoints": {
       "@myorg/public-api": "./packages/public-api/dist/index.d.ts"
     }
   }
   ```

### Memory Usage

For very large codebases:
- Use Node.js with increased memory: `node --max-old-space-size=8192 node_modules/.bin/dts-bundler`
- Consider splitting into multiple smaller bundles

## API Integration

Use the bundler programmatically:

```typescript
import { DTSBundler, BundlerConfigManager, DependencyGraph } from '@actioncrew/dts-bundler';

// Load configuration
const config = BundlerConfigManager.load('./my-config.json');

// Create program and dependency graph
const program = ts.createProgram(sourceFiles, compilerOptions);
const graph = new DependencyGraph(program, entryPoints);

// Bundle specific entry
const bundler = new DTSBundler({
  entryPoint: './dist/index.d.ts',
  outputFile: './bundles/my-package.bundle.d.ts',
  packageName: '@myorg/my-package'
}, graph);

await bundler.bundle();
```

## Migration Guide

### From Manual Declaration Management

If you're currently maintaining .d.ts files manually:

1. Set up your build to generate .d.ts files: `tsc --declaration`
2. Initialize bundler: `npx dts-bundler init`
3. Configure entry points in `dts-bundler.config.json`
4. Run bundler: `npx dts-bundler`
5. Update your package.json `types` field to point to bundles

### From Other Bundlers

The configuration is intentionally similar to other tools:

- **API Extractor**: Similar entry point concept, but focuses on .d.ts bundling only
- **Rollup**: Similar plugin architecture, but optimized for TypeScript declarations
- **Webpack**: Similar configuration approach, but specialized for type bundling

## License

MIT © 2025